// THIS FILE IS AUTOMATICALLY GENERATED BY `generateContractInterfaces.ts`. DO NOT EDIT BY HAND'

import { EventDescription, DecodedEvent, ParameterDescription, EncodableArray, EncodableTuple, decodeParameters, decodeEvent, decodeMethod } from '@zoltu/ethereum-abi-encoder'
export { EncodableArray, EncodableTuple }

export interface Log {
	readonly topics: ReadonlyArray<bigint>
	readonly data: Uint8Array
}
export interface TransactionReceipt {
	readonly status: boolean
	readonly logs: Iterable<Log>
}

export const eventDescriptions: { [signatureHash: string]: EventDescription & {signature: string} } = {
	'ee9c28a7fe7177d351e891cb4ca5b7a4e4aba4974be67fb7665ba1ad0e703439': {"type":"event","name":"ExecuteTransactionStatus","signature":"ExecuteTransactionStatus(bool,bool)","inputs":[{"type":"bool","name":"success","indexed":false},{"type":"bool","name":"fundingSuccess","indexed":false}]},
	'64d6bce64323458c44643c51fe45113efc882082f7b7fd5f09f0d69d2eedb202': {"type":"event","name":"RequestTypeRegistered","signature":"RequestTypeRegistered(bytes32,string)","inputs":[{"type":"bytes32","name":"typeHash","indexed":true},{"type":"string","name":"typeStr","indexed":false}]}
}

export namespace AugurWalletRegistryV2 {
	export interface ExecuteTransactionStatus extends DecodedEvent {
		name: 'ExecuteTransactionStatus'
		parameters: {
			success: boolean
			fundingSuccess: boolean
		}
	}
}

export namespace AugurWalletRegistryV2 {
	export interface RequestTypeRegistered extends DecodedEvent {
		name: 'RequestTypeRegistered'
		parameters: {
			typeHash: bigint
			typeStr: string
		}
	}
}

export type Event = DecodedEvent | AugurWalletRegistryV2.ExecuteTransactionStatus | AugurWalletRegistryV2.RequestTypeRegistered


export interface Dependencies {
	call(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<Uint8Array>
	submitTransaction(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<TransactionReceipt>
}


/**
 * By convention, pure/view methods have a `_` suffix on them indicating to the caller that the function will be executed locally and return the function's result.  payable/nonpayable functions have both a local version and a remote version (distinguished by the trailing `_`).  If the remote method is called, you will only get back a transaction hash which can be used to lookup the transaction receipt for success/failure (due to EVM limitations you will not get the function results back).
 */
export class Contract {
	protected constructor(protected readonly dependencies: Dependencies, public readonly address: bigint) { }

	protected async localCall(methodSignature: string, outputParameterDescriptions: ReadonlyArray<ParameterDescription>, methodParameters: EncodableArray, attachedEth?: bigint): Promise<EncodableTuple> {
		const result = await this.dependencies.call(this.address, methodSignature, methodParameters, attachedEth || 0n)
		if (result.length >= 4 && result[0] === 8 && result[1] === 195 && result[2] === 121 && result[3] === 160) {
			const decodedError = decodeMethod(0x08c379a0, [ { name: 'message', type: 'string' } ], result) as { message: string }
			throw new Error(`Contract Error: ${decodedError.message}`)
		}
		return decodeParameters(outputParameterDescriptions, result)
	}

	protected async remoteCall(methodSignature: string, parameters: EncodableArray, errorContext: { transactionName: string }, attachedEth?: bigint): Promise<Array<Event>> {
		const transactionReceipt = await this.dependencies.submitTransaction(this.address, methodSignature, parameters, attachedEth || 0n)
		if (!transactionReceipt.status) throw new Error(`Remote call of ${errorContext.transactionName} failed: ${JSON.stringify(transactionReceipt)}`)
		return this.decodeEvents(transactionReceipt.logs)
	}

	private decodeEvents(encodedEvents: Iterable<Log>): Array<Event> {
		const decodedEvents: Array<DecodedEvent> = []
		for (const encodedEvent of encodedEvents) {
			const decodedEvent = this.tryDecodeEvent(encodedEvent)
			if (decodedEvent) decodedEvents.push(decodedEvent)
		}
		return decodedEvents as Array<Event>
	}

	private tryDecodeEvent(encodedEvent: Log): DecodedEvent | null {
		const signatureHash = encodedEvent.topics[0]
		const eventDescription = eventDescriptions[signatureHash.toString(16)]
		if (!eventDescription) return null
		return decodeEvent(eventDescription, encodedEvent.topics, encodedEvent.data)
	}
}


export class AugurWalletRegistryV2 extends Contract {
	public constructor(dependencies: Dependencies, address: bigint) {
		super(dependencies, address)
	}

	public GENERIC_PARAMS_ = async (): Promise<string> => {
		const methodSignature = 'GENERIC_PARAMS()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"string","name":"","type":"string"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <string>result.result
	}

	public WETH_ = async (): Promise<bigint> => {
		const methodSignature = 'WETH()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"contract IWETH","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public _verifySig_ = async (req: { readonly from: bigint, readonly to: bigint, readonly value: bigint, readonly gas: bigint, readonly nonce: bigint, readonly data: Uint8Array }, suffixData: Uint8Array, sig: Uint8Array): Promise<void> => {
		const methodSignature = '_verifySig((address from, address to, uint256 value, uint256 gas, uint256 nonce, bytes data) req, bytes suffixData, bytes sig)' as const
		const methodParameters = [req, suffixData, sig] as const
		const outputParameterDescriptions = [] as const
		await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
	}

	public acceptRelayedCall_ = async (relayRequest: { readonly request: { readonly from: bigint, readonly to: bigint, readonly value: bigint, readonly gas: bigint, readonly nonce: bigint, readonly data: Uint8Array }, readonly relayData: { readonly gasPrice: bigint, readonly pctRelayFee: bigint, readonly baseRelayFee: bigint, readonly relayWorker: bigint, readonly paymaster: bigint, readonly paymasterData: Uint8Array, readonly clientId: bigint, readonly forwarder: bigint } }, signature: Uint8Array, approvalData: Uint8Array, maxPossibleGas: bigint): Promise<Uint8Array> => {
		const methodSignature = 'acceptRelayedCall(((address from, address to, uint256 value, uint256 gas, uint256 nonce, bytes data) request, (uint256 gasPrice, uint256 pctRelayFee, uint256 baseRelayFee, address relayWorker, address paymaster, bytes paymasterData, uint256 clientId, address forwarder) relayData) relayRequest, bytes signature, bytes approvalData, uint256 maxPossibleGas)' as const
		const methodParameters = [relayRequest, signature, approvalData, maxPossibleGas] as const
		const outputParameterDescriptions = [{"internalType":"bytes","name":"context","type":"bytes"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <Uint8Array>result.context
	}

	public augur_ = async (): Promise<bigint> => {
		const methodSignature = 'augur()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"contract IAugur","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public augurTrading_ = async (): Promise<bigint> => {
		const methodSignature = 'augurTrading()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"contract IAugurTrading","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public augurWalletFactory_ = async (): Promise<bigint> => {
		const methodSignature = 'augurWalletFactory()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"contract IAugurWalletFactory","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public cash_ = async (): Promise<bigint> => {
		const methodSignature = 'cash()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"contract IERC20","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public ethExchange_ = async (): Promise<bigint> => {
		const methodSignature = 'ethExchange()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"contract IUniswapV2Pair","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public execute = async (req: { readonly from: bigint, readonly to: bigint, readonly value: bigint, readonly gas: bigint, readonly nonce: bigint, readonly data: Uint8Array }, domainSeparator: bigint, requestTypeHash: bigint, suffixData: Uint8Array, sig: Uint8Array, attachedEth?: bigint): Promise<Array<Event>> => {
		const methodSignature = 'execute((address from, address to, uint256 value, uint256 gas, uint256 nonce, bytes data) req, bytes32 domainSeparator, bytes32 requestTypeHash, bytes suffixData, bytes sig)' as const
		const methodParameters = [req, domainSeparator, requestTypeHash, suffixData, sig] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'execute' }, attachedEth)
	}

	public execute_ = async (req: { readonly from: bigint, readonly to: bigint, readonly value: bigint, readonly gas: bigint, readonly nonce: bigint, readonly data: Uint8Array }, domainSeparator: bigint, requestTypeHash: bigint, suffixData: Uint8Array, sig: Uint8Array, attachedEth?: bigint): Promise<{success: boolean, ret: Uint8Array}> => {
		const methodSignature = 'execute((address from, address to, uint256 value, uint256 gas, uint256 nonce, bytes data) req, bytes32 domainSeparator, bytes32 requestTypeHash, bytes suffixData, bytes sig)' as const
		const methodParameters = [req, domainSeparator, requestTypeHash, suffixData, sig] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"success","type":"bool"},{"internalType":"bytes","name":"ret","type":"bytes"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters, attachedEth)
		return <{success: boolean, ret: Uint8Array}>result
	}

	public executeWalletTransaction = async (to: bigint, data: Uint8Array, value: bigint, payment: bigint, referralAddress: bigint, fingerprint: bigint, desiredSignerBalance: bigint, maxExchangeRateInDai: bigint, revertOnFailure: boolean): Promise<Array<Event>> => {
		const methodSignature = 'executeWalletTransaction(address _to, bytes _data, uint256 _value, uint256 _payment, address _referralAddress, bytes32 _fingerprint, uint256 _desiredSignerBalance, uint256 _maxExchangeRateInDai, bool _revertOnFailure)' as const
		const methodParameters = [to, data, value, payment, referralAddress, fingerprint, desiredSignerBalance, maxExchangeRateInDai, revertOnFailure] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'executeWalletTransaction' })
	}

	public executeWalletTransaction_ = async (to: bigint, data: Uint8Array, value: bigint, payment: bigint, referralAddress: bigint, fingerprint: bigint, desiredSignerBalance: bigint, maxExchangeRateInDai: bigint, revertOnFailure: boolean): Promise<void> => {
		const methodSignature = 'executeWalletTransaction(address _to, bytes _data, uint256 _value, uint256 _payment, address _referralAddress, bytes32 _fingerprint, uint256 _desiredSignerBalance, uint256 _maxExchangeRateInDai, bool _revertOnFailure)' as const
		const methodParameters = [to, data, value, payment, referralAddress, fingerprint, desiredSignerBalance, maxExchangeRateInDai, revertOnFailure] as const
		const outputParameterDescriptions = [] as const
		await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
	}

	public getAmountIn_ = async (amountOut: bigint, reserveIn: bigint, reserveOut: bigint): Promise<bigint> => {
		const methodSignature = 'getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)' as const
		const methodParameters = [amountOut, reserveIn, reserveOut] as const
		const outputParameterDescriptions = [{"internalType":"uint256","name":"amountIn","type":"uint256"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.amountIn
	}

	public getAmountOut_ = async (amountIn: bigint, reserveIn: bigint, reserveOut: bigint): Promise<bigint> => {
		const methodSignature = 'getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)' as const
		const methodParameters = [amountIn, reserveIn, reserveOut] as const
		const outputParameterDescriptions = [{"internalType":"uint256","name":"amountOut","type":"uint256"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.amountOut
	}

	public getCreate2WalletAddress_ = async (owner: bigint): Promise<bigint> => {
		const methodSignature = 'getCreate2WalletAddress(address _owner)' as const
		const methodParameters = [owner] as const
		const outputParameterDescriptions = [{"internalType":"address","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public getGasLimits_ = async (): Promise<{ acceptRelayedCallGasLimit: bigint, preRelayedCallGasLimit: bigint, postRelayedCallGasLimit: bigint }> => {
		const methodSignature = 'getGasLimits()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"components":[{"internalType":"uint256","name":"acceptRelayedCallGasLimit","type":"uint256"},{"internalType":"uint256","name":"preRelayedCallGasLimit","type":"uint256"},{"internalType":"uint256","name":"postRelayedCallGasLimit","type":"uint256"}],"internalType":"struct IPaymaster.GasLimits","name":"limits","type":"tuple"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <{ acceptRelayedCallGasLimit: bigint, preRelayedCallGasLimit: bigint, postRelayedCallGasLimit: bigint }>result.limits
	}

	public getHubAddr_ = async (): Promise<bigint> => {
		const methodSignature = 'getHubAddr()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"address","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public getInitialized_ = async (): Promise<boolean> => {
		const methodSignature = 'getInitialized()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public getNonce_ = async (from: bigint): Promise<bigint> => {
		const methodSignature = 'getNonce(address from)' as const
		const methodParameters = [from] as const
		const outputParameterDescriptions = [{"internalType":"uint256","name":"","type":"uint256"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public getRelayHubDeposit_ = async (): Promise<bigint> => {
		const methodSignature = 'getRelayHubDeposit()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"uint256","name":"","type":"uint256"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public getRelayMessageHash_ = async (req: { readonly request: { readonly from: bigint, readonly to: bigint, readonly value: bigint, readonly gas: bigint, readonly nonce: bigint, readonly data: Uint8Array }, readonly relayData: { readonly gasPrice: bigint, readonly pctRelayFee: bigint, readonly baseRelayFee: bigint, readonly relayWorker: bigint, readonly paymaster: bigint, readonly paymasterData: Uint8Array, readonly clientId: bigint, readonly forwarder: bigint } }): Promise<bigint> => {
		const methodSignature = 'getRelayMessageHash(((address from, address to, uint256 value, uint256 gas, uint256 nonce, bytes data) request, (uint256 gasPrice, uint256 pctRelayFee, uint256 baseRelayFee, address relayWorker, address paymaster, bytes paymasterData, uint256 clientId, address forwarder) relayData) req)' as const
		const methodParameters = [req] as const
		const outputParameterDescriptions = [{"internalType":"bytes32","name":"","type":"bytes32"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public getWallet_ = async (account: bigint): Promise<bigint> => {
		const methodSignature = 'getWallet(address _account)' as const
		const methodParameters = [account] as const
		const outputParameterDescriptions = [{"internalType":"contract IAugurWallet","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public initialize = async (augur: bigint, augurTrading: bigint, attachedEth?: bigint): Promise<Array<Event>> => {
		const methodSignature = 'initialize(address _augur, address _augurTrading)' as const
		const methodParameters = [augur, augurTrading] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'initialize' }, attachedEth)
	}

	public initialize_ = async (augur: bigint, augurTrading: bigint, attachedEth?: bigint): Promise<boolean> => {
		const methodSignature = 'initialize(address _augur, address _augurTrading)' as const
		const methodParameters = [augur, augurTrading] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters, attachedEth)
		return <boolean>result.result
	}

	public isTrustedForwarder_ = async (forwarder: bigint): Promise<boolean> => {
		const methodSignature = 'isTrustedForwarder(address forwarder)' as const
		const methodParameters = [forwarder] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public postRelayedCall = async (context: Uint8Array, success: boolean, preRetVal: bigint, gasUseWithoutPost: bigint, relayData: { readonly gasPrice: bigint, readonly pctRelayFee: bigint, readonly baseRelayFee: bigint, readonly relayWorker: bigint, readonly paymaster: bigint, readonly paymasterData: Uint8Array, readonly clientId: bigint, readonly forwarder: bigint }): Promise<Array<Event>> => {
		const methodSignature = 'postRelayedCall(bytes context, bool success, bytes32 preRetVal, uint256 gasUseWithoutPost, (uint256 gasPrice, uint256 pctRelayFee, uint256 baseRelayFee, address relayWorker, address paymaster, bytes paymasterData, uint256 clientId, address forwarder) relayData)' as const
		const methodParameters = [context, success, preRetVal, gasUseWithoutPost, relayData] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'postRelayedCall' })
	}

	public postRelayedCall_ = async (context: Uint8Array, success: boolean, preRetVal: bigint, gasUseWithoutPost: bigint, relayData: { readonly gasPrice: bigint, readonly pctRelayFee: bigint, readonly baseRelayFee: bigint, readonly relayWorker: bigint, readonly paymaster: bigint, readonly paymasterData: Uint8Array, readonly clientId: bigint, readonly forwarder: bigint }): Promise<boolean> => {
		const methodSignature = 'postRelayedCall(bytes context, bool success, bytes32 preRetVal, uint256 gasUseWithoutPost, (uint256 gasPrice, uint256 pctRelayFee, uint256 baseRelayFee, address relayWorker, address paymaster, bytes paymasterData, uint256 clientId, address forwarder) relayData)' as const
		const methodParameters = [context, success, preRetVal, gasUseWithoutPost, relayData] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public preRelayedCall_ = async (context: Uint8Array): Promise<boolean> => {
		const methodSignature = 'preRelayedCall(bytes context)' as const
		const methodParameters = [context] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public registerRequestType = async (typeName: string, typeSuffix: string): Promise<Array<Event>> => {
		const methodSignature = 'registerRequestType(string typeName, string typeSuffix)' as const
		const methodParameters = [typeName, typeSuffix] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'registerRequestType' })
	}

	public registerRequestType_ = async (typeName: string, typeSuffix: string): Promise<void> => {
		const methodSignature = 'registerRequestType(string typeName, string typeSuffix)' as const
		const methodParameters = [typeName, typeSuffix] as const
		const outputParameterDescriptions = [] as const
		await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
	}

	public token0IsCash_ = async (): Promise<boolean> => {
		const methodSignature = 'token0IsCash()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public typeHashes_ = async (arg0: bigint): Promise<boolean> => {
		const methodSignature = 'typeHashes(bytes32 )' as const
		const methodParameters = [arg0] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public verify_ = async (req: { readonly from: bigint, readonly to: bigint, readonly value: bigint, readonly gas: bigint, readonly nonce: bigint, readonly data: Uint8Array }, suffixData: Uint8Array, sig: Uint8Array): Promise<void> => {
		const methodSignature = 'verify((address from, address to, uint256 value, uint256 gas, uint256 nonce, bytes data) req, bytes suffixData, bytes sig)' as const
		const methodParameters = [req, suffixData, sig] as const
		const outputParameterDescriptions = [] as const
		await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
	}

	public versionRecipient_ = async (): Promise<string> => {
		const methodSignature = 'versionRecipient()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"string","name":"","type":"string"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <string>result.result
	}
}
