// THIS FILE IS AUTOMATICALLY GENERATED BY `generateContractInterfaces.ts`. DO NOT EDIT BY HAND'

import { EventDescription, DecodedEvent, ParameterDescription, EncodableArray, EncodableTuple, decodeParameters, decodeEvent, decodeMethod } from '@zoltu/ethereum-abi-encoder'
export { EncodableArray, EncodableTuple }

export interface Log {
	readonly topics: ReadonlyArray<bigint>
	readonly data: Uint8Array
}
export interface TransactionReceipt {
	readonly status: boolean
	readonly logs: Iterable<Log>
}

export const eventDescriptions: { [signatureHash: string]: EventDescription & {signature: string} } = {

}



export type Event = DecodedEvent


export interface Dependencies {
	call(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<Uint8Array>
	submitTransaction(address: bigint, methodSignature: string, methodParameters: EncodableArray, value: bigint): Promise<TransactionReceipt>
}


/**
 * By convention, pure/view methods have a `_` suffix on them indicating to the caller that the function will be executed locally and return the function's result.  payable/nonpayable functions have both a local version and a remote version (distinguished by the trailing `_`).  If the remote method is called, you will only get back a transaction hash which can be used to lookup the transaction receipt for success/failure (due to EVM limitations you will not get the function results back).
 */
export class Contract {
	protected constructor(protected readonly dependencies: Dependencies, public readonly address: bigint) { }

	protected async localCall(methodSignature: string, outputParameterDescriptions: ReadonlyArray<ParameterDescription>, methodParameters: EncodableArray, attachedEth?: bigint): Promise<EncodableTuple> {
		const result = await this.dependencies.call(this.address, methodSignature, methodParameters, attachedEth || 0n)
		if (result.length >= 4 && result[0] === 8 && result[1] === 195 && result[2] === 121 && result[3] === 160) {
			const decodedError = decodeMethod(0x08c379a0, [ { name: 'message', type: 'string' } ], result) as { message: string }
			throw new Error(`Contract Error: ${decodedError.message}`)
		}
		return decodeParameters(outputParameterDescriptions, result)
	}

	protected async remoteCall(methodSignature: string, parameters: EncodableArray, errorContext: { transactionName: string }, attachedEth?: bigint): Promise<Array<Event>> {
		const transactionReceipt = await this.dependencies.submitTransaction(this.address, methodSignature, parameters, attachedEth || 0n)
		if (!transactionReceipt.status) throw new Error(`Remote call of ${errorContext.transactionName} failed: ${JSON.stringify(transactionReceipt)}`)
		return this.decodeEvents(transactionReceipt.logs)
	}

	private decodeEvents(encodedEvents: Iterable<Log>): Array<Event> {
		const decodedEvents: Array<DecodedEvent> = []
		for (const encodedEvent of encodedEvents) {
			const decodedEvent = this.tryDecodeEvent(encodedEvent)
			if (decodedEvent) decodedEvents.push(decodedEvent)
		}
		return decodedEvents as Array<Event>
	}

	private tryDecodeEvent(encodedEvent: Log): DecodedEvent | null {
		const signatureHash = encodedEvent.topics[0]
		const eventDescription = eventDescriptions[signatureHash.toString(16)]
		if (!eventDescription) return null
		return decodeEvent(eventDescription, encodedEvent.topics, encodedEvent.data)
	}
}


export class AugurWallet extends Contract {
	public constructor(dependencies: Dependencies, address: bigint) {
		super(dependencies, address)
	}

	public DOMAIN_SEPARATOR_TYPEHASH_ = async (): Promise<bigint> => {
		const methodSignature = 'DOMAIN_SEPARATOR_TYPEHASH()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"bytes32","name":"","type":"bytes32"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public MSG_TYPEHASH_ = async (): Promise<bigint> => {
		const methodSignature = 'MSG_TYPEHASH()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"bytes32","name":"","type":"bytes32"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public addAuthorizedProxy = async (authorizedProxy: bigint): Promise<Array<Event>> => {
		const methodSignature = 'addAuthorizedProxy(address _authorizedProxy)' as const
		const methodParameters = [authorizedProxy] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'addAuthorizedProxy' })
	}

	public addAuthorizedProxy_ = async (authorizedProxy: bigint): Promise<boolean> => {
		const methodSignature = 'addAuthorizedProxy(address _authorizedProxy)' as const
		const methodParameters = [authorizedProxy] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public authorizedProxies_ = async (arg0: bigint): Promise<boolean> => {
		const methodSignature = 'authorizedProxies(address )' as const
		const methodParameters = [arg0] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public cash_ = async (): Promise<bigint> => {
		const methodSignature = 'cash()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"contract IERC20","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public domainSeparator_ = async (): Promise<bigint> => {
		const methodSignature = 'domainSeparator()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"bytes32","name":"","type":"bytes32"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public executeTransaction = async (to: bigint, data: Uint8Array, value: bigint): Promise<Array<Event>> => {
		const methodSignature = 'executeTransaction(address _to, bytes _data, uint256 _value)' as const
		const methodParameters = [to, data, value] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'executeTransaction' })
	}

	public executeTransaction_ = async (to: bigint, data: Uint8Array, value: bigint): Promise<boolean> => {
		const methodSignature = 'executeTransaction(address _to, bytes _data, uint256 _value)' as const
		const methodParameters = [to, data, value] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public getAmountOut_ = async (amountIn: bigint, reserveIn: bigint, reserveOut: bigint): Promise<bigint> => {
		const methodSignature = 'getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)' as const
		const methodParameters = [amountIn, reserveIn, reserveOut] as const
		const outputParameterDescriptions = [{"internalType":"uint256","name":"amountOut","type":"uint256"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.amountOut
	}

	public getInitialized_ = async (): Promise<boolean> => {
		const methodSignature = 'getInitialized()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public getMessageHash_ = async (message: Uint8Array): Promise<bigint> => {
		const methodSignature = 'getMessageHash(bytes _message)' as const
		const methodParameters = [message] as const
		const outputParameterDescriptions = [{"internalType":"bytes32","name":"","type":"bytes32"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public initialize = async (owner: bigint, referralAddress: bigint, fingerprint: bigint, augur: bigint, registry: bigint, registryV2: bigint, cash: bigint, affiliates: bigint, shareToken: bigint, createOrder: bigint, fillOrder: bigint, zeroXTrade: bigint): Promise<Array<Event>> => {
		const methodSignature = 'initialize(address _owner, address _referralAddress, bytes32 _fingerprint, address _augur, address _registry, address _registryV2, address _cash, address _affiliates, address _shareToken, address _createOrder, address _fillOrder, address _zeroXTrade)' as const
		const methodParameters = [owner, referralAddress, fingerprint, augur, registry, registryV2, cash, affiliates, shareToken, createOrder, fillOrder, zeroXTrade] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'initialize' })
	}

	public initialize_ = async (owner: bigint, referralAddress: bigint, fingerprint: bigint, augur: bigint, registry: bigint, registryV2: bigint, cash: bigint, affiliates: bigint, shareToken: bigint, createOrder: bigint, fillOrder: bigint, zeroXTrade: bigint): Promise<void> => {
		const methodSignature = 'initialize(address _owner, address _referralAddress, bytes32 _fingerprint, address _augur, address _registry, address _registryV2, address _cash, address _affiliates, address _shareToken, address _createOrder, address _fillOrder, address _zeroXTrade)' as const
		const methodParameters = [owner, referralAddress, fingerprint, augur, registry, registryV2, cash, affiliates, shareToken, createOrder, fillOrder, zeroXTrade] as const
		const outputParameterDescriptions = [] as const
		await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
	}

	public isValidSignature_ = async (data: Uint8Array, signature: Uint8Array): Promise<bigint> => {
		const methodSignature = 'isValidSignature(bytes _data, bytes _signature)' as const
		const methodParameters = [data, signature] as const
		const outputParameterDescriptions = [{"internalType":"bytes4","name":"","type":"bytes4"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public registry_ = async (): Promise<bigint> => {
		const methodSignature = 'registry()' as const
		const methodParameters = [] as const
		const outputParameterDescriptions = [{"internalType":"contract IAugurWalletRegistry","name":"","type":"address"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <bigint>result.result
	}

	public removeAuthorizedProxy = async (authorizedProxy: bigint): Promise<Array<Event>> => {
		const methodSignature = 'removeAuthorizedProxy(address _authorizedProxy)' as const
		const methodParameters = [authorizedProxy] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'removeAuthorizedProxy' })
	}

	public removeAuthorizedProxy_ = async (authorizedProxy: bigint): Promise<boolean> => {
		const methodSignature = 'removeAuthorizedProxy(address _authorizedProxy)' as const
		const methodParameters = [authorizedProxy] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
		return <boolean>result.result
	}

	public transferCash = async (to: bigint, amount: bigint): Promise<Array<Event>> => {
		const methodSignature = 'transferCash(address _to, uint256 _amount)' as const
		const methodParameters = [to, amount] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'transferCash' })
	}

	public transferCash_ = async (to: bigint, amount: bigint): Promise<void> => {
		const methodSignature = 'transferCash(address _to, uint256 _amount)' as const
		const methodParameters = [to, amount] as const
		const outputParameterDescriptions = [] as const
		await this.localCall(methodSignature, outputParameterDescriptions, methodParameters)
	}

	public withdrawAllFundsAsDai = async (destination: bigint, minExchangeRateInDai: bigint, attachedEth?: bigint): Promise<Array<Event>> => {
		const methodSignature = 'withdrawAllFundsAsDai(address _destination, uint256 _minExchangeRateInDai)' as const
		const methodParameters = [destination, minExchangeRateInDai] as const
		return await this.remoteCall(methodSignature, methodParameters, { transactionName: 'withdrawAllFundsAsDai' }, attachedEth)
	}

	public withdrawAllFundsAsDai_ = async (destination: bigint, minExchangeRateInDai: bigint, attachedEth?: bigint): Promise<boolean> => {
		const methodSignature = 'withdrawAllFundsAsDai(address _destination, uint256 _minExchangeRateInDai)' as const
		const methodParameters = [destination, minExchangeRateInDai] as const
		const outputParameterDescriptions = [{"internalType":"bool","name":"","type":"bool"}] as const
		const result = await this.localCall(methodSignature, outputParameterDescriptions, methodParameters, attachedEth)
		return <boolean>result.result
	}
}
